

  // Evaluate spline w/_coefs
  // Mark _timeout if setpoint has timed out
  // Thus, **MUST** check for timeout after calling update()
  math::Vector<SETPOINT_POSE_LEN> eval() {
    math::Vector<SETPOINT_POSE_LEN> s;
    update();
    if (_timeout) return s;
    else return eval_at(_dt);
  }

  math::Vector<SETPOINT_POSE_LEN> get_start() {
    math::Vector<SETPOINT_POSE_LEN> s;
    s(0) = _coefs[SETPOINT_X](5);
    s(1) = _coefs[SETPOINT_Y](5);
    s(2) = _coefs[SETPOINT_Z](5);
    s(3) = _coefs[SETPOINT_X](4);
    s(4) = _coefs[SETPOINT_Y](4);
    s(5) = _coefs[SETPOINT_Z](4);
    s(6) = _coefs[SETPOINT_YAW](5);
    s(7) = _coefs[SETPOINT_YAW](4);
    return s;
  }

  math::Vector<SETPOINT_POSE_LEN> get_end() {
    return eval_at(_dt_tot);
  }

  void set_pose_error(pose_stamped_s* p, pose_stamped_s* e) {
    math::Vector<3>eul_err;
    math::Vector<SETPOINT_POSE_LEN> setpoint = eval();

    // Check for timeout
    if (_timeout) {
      e->pose.zero();
      return;
    }

    e->pose(0)=setpoint(0)-p->pose(0); // x
    e->pose(1)=setpoint(1)-p->pose(1); // y
    e->pose(2)=setpoint(2)-p->pose(2); // z
    e->pose(3)=setpoint(3)-p->pose(3); // vx
    e->pose(4)=setpoint(4)-p->pose(4); // vy
    e->pose(5)=setpoint(5)-p->pose(5); // vz
    e->pose(12)=setpoint(7)-p->pose(12); // yawrate

    // euler angles
    eul_err=p->get_eul();
    eul_err(0) = 0; // roll
    eul_err(1) = 0; // pitch
    eul_err(2) = setpoint(6) - eul_err(2); // yaw
    e->set_eul(eul_err);
    e->base_thrust = _base_thrust;
}c
